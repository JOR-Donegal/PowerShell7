{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":"<p>Introduction to Power Shell 7</p> <p>You have already learned how to use the old command prompt (CLI) in Windows, and you should appreciate that it is a bit archaic and unintuitive. In an OS which has been in use for over 30 years, Microsoft must maintain consistency with the bad and uninformed decisions of a generation ago.</p> <p>Not just that; the DOS/Windows command was originally designed to be simple for the average non-technical user to operate a computer. In the 1970s and 80s, for the first time is history, people who were not computer scientists were working directly with computers.</p> <p>A CLI has no built-in menus, no way to provide hints and assistance to users as to what commands exist and how to use them. Microsoft knew they needed something more powerful and flexible, to give the sort of functionality Linux administrators were used to. </p> <p>In the post MS-DOS era, all the development effort of Microsoft went into making an intuitive graphical user interface (GUI), not into enhancing the command prompt. In Windows, you interface with the system through the Application Programmers Interface (API), which was intended for calling from C and C++, not from a command line. Windows is tough to program even in C! Yet the CLI is how most administrators want to configure things; it is repeatable, predictable, and economical. Another problem is that Windows, most modern operating system, and programming languages, are object oriented. CLIs do not manipulate objects, they manipulate text files.</p> <p>Around 2000, Microsoft ran an internal study to see what it most needed to do to improve its server products. Management tools, in particular the CLI, was one of the priorities identified and the issues mentioned above had to be considered. The obvious and easy thing to do would be to use existing shell commands and an existing language like the Unix Bash shell. However, none of these shells were object based. Every platform had to deal with these issues, and this led to the Distributed Management Task Force [1] being set up and the establishment of a Common Information Model (CIM) for management objects. Microsoft implemented this as Windows Management Instrumentation (WMI )and as you get into PowerShell, you will use this extensively.</p> <p>Microsoft had already moved their entire platform to .NET, and it made sense to base the new language around the same concepts. The .NET framework is self-describing; that is the objects have a definition of their structure within them. It also meant the new language already had access to the entire set of libraries within .NET. </p> <p>In more recent years, PowerShell has become cross-platform, running on Windows, Linux and MacOS. </p> <p>The public cloud platform Azure also uses PowerShell.</p>"},{"location":"1.%20Background/1/","title":"History","text":"<p>PowerShell has been around for a while. - v1.0 was released in 2006 and it was an add-on, a free download. The interface looks just like the old command line. - v2.0 was released in 2009, pre-installed by default in Windows 7 and Server 2008 with new features, including remoting and PowerShell Integrated Scripting Environment. - v3.0 was released in 2012, pre-installed by default in Windows 8 and Server 2012. This included online updates for help and IntelliSense for the ISE. - v4.0 was released in 2013, pre-installed by default in Windows 8.1 and Server 2012 R2. This included improvements in script security and debugging. - v5.0 was released in 2016, pre-installed by default in Windows 10 and Server 2016. This included support for repositories and switch management (!). </p> <p>On current machines, if you have all the updates, from January 2017 you are currently on v5.1. All my current machines are all on 5.1 and it is based on the .NET Framework version 4.5.2 </p> <p>From 2014, Microsoft announced .Net Core for cross-platform support. This runs on Windows, Linux, and MAC OS. .Net Core 1.0 was released in 2016 but after a few versions (and to create endless confusion) Microsoft abandoned the Core naming structure.</p> <p>There is a PowerShell v5 (2020) and v6.0 (2021).</p> <p>Version 7 was released in March 2020, at time of writing we are at v7.3</p>"},{"location":"1.%20Background/2/","title":"Design","text":"<p>PowerShell was designed specifically for systems administration and was designed based on years of experience with both the old command prompt and with the Unix shell. As with most things in Windows, PowerShell was based on the .NET common language runtime (CLR) and framework and can thus manipulate .NET objects rather than just text and text files. </p> <p>In Unix - An early design criterion was that every command should have one and only one function. Simplicity leads to ease of use and training, less bugs, less security issues, easier maintainability, etc. PowerShell brings a new concept, the cmdlet, which follows the same sort of logic. - We can pipe the output of one command into another and we can do the same in PowerShell using the pipe | symbol. - We can assemble complex lists of commands into scripts, with all the advantages we have previously discussed. A task becomes self-documenting, repeatable and institutionalised by scripting. These scripts then become your own cmdlets. </p> <p>PowerShell still isn\u2019t the most readable or understandable language in the world. Part of the reason is that objects vary from language to language and part of the task of getting used to any language is learning the common objects which is exposes. </p> <p>PowerShell is now deeply embedded in Microsoft products and realistically, all Microsoft administrators need to know how to use it now. Whenever you configure modern versions of Windows server, you can extract the PowerShell commands behind the GUI. </p> <p>All cmdlets have a structure of verb-noun, not case sensitive. A verb means do something like get, read information from the system somewhere. NetIPAddress is a noun, a thing. I can type</p> <pre><code>get-netipaddress\n</code></pre> <p>and that is a valid command.</p> <p>Every cmdlet in PowerShell is organised in modules of related materials. For example, if I\u2019m working on DNS, I will load the DNS module. Not all modules are loaded by default. There are four module types.</p> <ul> <li>Script Modules (.psm1) hold functions</li> <li>Manifest Modules (.psd1) hold metadata and instructions</li> <li>Binary Modules are written in C# and compiled into a .dll file</li> <li>Dynamic Modules are created on demand, in memory</li> </ul>"},{"location":"1.%20Background/2/#variables","title":"Variables","text":"<p>In PowerShell, variables are represented by text strings prefixed with a dollar sign ($). In coding, we create user defined variables. There are some automatic state variables which PowerShell itself keeps for housekeeping. There are also user preference variables, populated with default values but changeable.</p>"},{"location":"1.%20Background/3/","title":"Using Powershell","text":"<p>There are a few ways we can interact with PowerShell directly. There is a command windows which looks the same as the old command prompt. </p> <p>There is also a full graphical development environment called the Integrated Scripting Environment or ISE. Remember, the objective here is not just to write handy single lines of code. The reasons we script are to permanently record, formalise, document, and institutionalise all those tasks that we must do more than once. Scripts are how we make administration efficient.</p> Fig 1. Power Shell ISE. <p>From version 7, the ISE is deprecated, and Visual Studio Code is recommended.\u2003</p> <p>PowerShell 7.x does not come preinstalled; we need to download it. PowerShell 5.1 is built in living at C:\\Windows\\System32\\WindowsPowerShell. The original tool for working with PowerShell was the command prompt or an IDE called the ISE. In the search bar, type PowerShell and launch the Windows PowerShell ISE as administrator (right-click to do so). In View, I click to show the script pane.</p> <p>If I type</p> <p><pre><code>$PSVersiontable\n</code></pre> into the script window and click Run, I can check the version.</p> Fig 2. Check Power Shell version."},{"location":"1.%20Background/4/","title":"Execution Policy","text":"<p>By default, PowerShell will not let me run scripts, even though I am administrator. I must manually set the execution policy. If I highlight a command, I can click Run Selection to run just that command.</p> Fig 3. Set execution policy."},{"location":"1.%20Background/5/","title":"PowerShell Gallery","text":"<p>As with most code platforms these days, there is a repo! The PowerShell Gallery is this repo and you can download modules using PowerShellGet.  To work with this gallery, you need some underlying tools and Nuget is the package manager for .Net. </p> <p>I have started adding comments!</p> <p>I can run a selection by pressing the button indicated in Fig 4.</p> Fig 4. Installing Power Shell gallery. <p>I install nuget, and install a module PowerShellGet.</p> <pre><code>Install-PackageProvider Nuget -MinimumVersion 2.8.5.201 -Force | Out-Null\nInstall-Module -Name PowerShellGet -Force -AllowClobber\nmkdir c:\\PowerShell\n</code></pre>"},{"location":"2.%20Power%20Shell%207/1/","title":"Install PowerShell 7","text":"<p>Powershell Core is intended to be the future of Powershell. It is intended to be multi-platform, supporting Windows, Linux and MacOS. At time of writing, I am on PowerShell 7.4. I am working on a VM, so I create a folder called C:\\PowerShell. I will copy these scripts to my OneDrive whenever I finish an exercise. </p> <p>I add the line mkdir c:\\PowerShell to my script and run it. </p> <p>I save this script as 1. Setup.ps1 </p> <p>From this point onwards, ensure you save all your working scripts as I suggest, you will need to submit these later.</p> <pre><code># Check the existing version\n$PSVersiontable\n# Set an execution policy\nSet-ExecutionPolicy -ExecutionPolicy RemoteSigned -Force\n# Install Nuget as a package provider\nInstall-PackageProvider Nuget -MinimumVersion 2.8.5.201 -Force | Out-Null\n# Install the module\nInstall-Module -Name PowerShellGet -Force -AllowClobber\n# Create a script directory\nmkdir c:\\PowerShell\n</code></pre>"},{"location":"2.%20Power%20Shell%207/1/#download-powershell-7","title":"Download PowerShell 7","text":"<p>Next, I open a new script window and save it as 2. Download PowerShell7.ps1</p> <p>Microsoft have a generic script they make available, I past this into the new script window and save. I run the script, no errors.</p> <pre><code># Download PowerShell 7 installation script\nSet-Location C:\\PowerShell\n$URI = \"https://aka.ms/install-powershell.ps1\"\nInvoke-RestMethod -Uri $URI | \nOut-File -FilePath C:\\PowerShell\\Install-PowerShell.ps1\n</code></pre>"},{"location":"2.%20Power%20Shell%207/1/#install-powershell-7_1","title":"Install PowerShell 7","text":"<p>If I run the command Get-Help -Name C:\\PowerShell\\Install-PowerShell.ps1 I can see how the script can be used. My computer added some modules automatically when I used Get-Help.</p> <p>I could run a very long command line, but there is a more elegant way to do this in PowerShell. I create a new script as 3. Install PowerShell 7.ps1 and set up the parameters in a variable and then pass then using @variable_name.</p> Fig 5. Installing Power Shell 7. <p>When I run the script, I note that everything downloads from GitHub!</p>"},{"location":"2.%20Power%20Shell%207/1/#verifying-installation","title":"Verifying Installation","text":"<p>The commands in PowerShell are sorted into modules. You can manually import modules of use autoload. If a module is called which has not been installed, PowerShell will fetch it.</p> <p>In PowerShell, we define variables using a $ symbol. Try the command echo $env:PSModulePath The output is three separate paths, concatenated with a semicolon field separator. I create a new script window 4. Verify PowerShell 7.ps1</p> <pre><code>$I = 0\n$env:PSModulePath -split ';' |\nForeach-Object {\"[{0:N0}] {1}\" -f $I++, $_}\n</code></pre> <p>What is this script doing? </p> <p>First it sets the variable $I = 0, </p> <p>Then it uses a split function to break up and pipes the output using the | symbol to a for-each loop. </p> <p>The loop syntax will make more sense when we cover loops. </p> <p>But now we know the locations of the modules PowerShell uses. </p> <p>Close ISE, we will not be using it again for now. Open a command window and run PowerShell 7 by typing pwsh, then verify the version as we did before.</p> Fig 6. Verify Power Shell 7."},{"location":"2.%20Power%20Shell%207/2/","title":"Visual Studio Code","text":"<p>Using Windows Navigator, I go to C:\\Powershell, right-click and open VSCode. I go to Extensions and install Powershell 7.</p> Fig 7. Power Shell 7 Extensions. <p>I load up script 4. Verify PowerShell 7.ps1 from earlier and run it to test. VSC has made some changes, but everything works. I have changed to a light background!</p> Fig 8. Verify Shell 7 Extensions. <p>In the immediate window, I can check which repository PowerShell and VSC will use.</p> Fig 9. Verify repositories."},{"location":"2.%20Power%20Shell%207/3/","title":"Tests","text":"<p>I wonder how many modules are available from the PS Gallery? I created 5. FindModules.ps1 and it took a while to run!</p> Fig 10. Find Power Shell 7 modules. <p>How many of these modules support PSCore? I created 6. FindModulesPSCore.ps1</p> Fig 11. Find Power Shell 7 PSCore modules. <p>The command </p> <pre><code>get-module -ListAvailable\n</code></pre> <p>will give you some idea of the total modules available to you.</p>"},{"location":"2.%20Power%20Shell%207/3/#finally","title":"Finally","text":"<p>Now you have run - PowerShell 5.1 using the terminal and ISE - PowerShell 7.x using the terminal and VSCode </p> <p>This is a starting point! </p>"},{"location":"3.%20Coding%20in%20Power%20Shell/1/","title":"Introduction","text":"<p>PowerShell is just another programming language. In previous notes I have covered the basics of any procedural language. You can expect to find variables, types, loops and all the other normal facets of a programming language.</p> <p>At the end of the last section, you had C:\\PowerShell synch'd with a GitHub repo. You also had a backup copy of your scripts on your OneDrive. Continue to save the work in this section in each of these locations.</p> <p>When you sync your scripts up to GitHub verify they are there. This will be graded at the end of the module.</p>"},{"location":"3.%20Coding%20in%20Power%20Shell/2/","title":"Creating a module","text":"<p>Microsoft's definition of a module is that it is \"a package that contains PowerShell members, such as cmdlets, providers, functions, workflows, variables, and aliases.\" I can create a simple module by running this code at the command prompt, one line at a time.</p> <p><pre><code>$MyModulePath = \"C:\\Users\\$env:USERNAME\\Documents\\PowerShell\\Modules\\HelloWorld\"\n\n$MyModule = @\"\n# HelloWorld.PSM1\nFunction Get-HelloWorld {\n \"Hello World from JOR\"\n}\n\"@\n\nNew-Item -Path $MyModulePath -ItemType Directory -Force | Out-Null\n$MyModule | Out-File -FilePath $MyModulePath\\HelloWorld.PSM1\nGet-Module -Name HelloWorld -ListAvailable\n</code></pre> My console displays</p> Fig 12. Module output. <p>I check that the file has been created.</p> Fig 13. File creation. <p>Change directory to HelloWorld and examine the file.</p> Fig 14. Examine File. <p>And now I can run the module Get-HelloWorld</p> Fig 15. Run test."},{"location":"3.%20Coding%20in%20Power%20Shell/3/","title":"Variables","text":"<p>I have based these notes on this reference. I presume you have already done some programming with me (or someone else), so I'm diving straight in without exhaustive explanation. The default value of any variable is $null. </p> <p>Type the command </p> <p><pre><code>Get-Variable \n</code></pre> to see what is currently defined by default. The assignment operator is = and I can create a variable and print it as shown below. Run these lines one at a time. <pre><code>$Rubbish = 1, 2, \"a\", \"\u00a3\u00a3\"\n$Rubbish\nclear-variable -Name Rubbish\n$Rubbish\nRemove-Variable -Name Rubbish \n</code></pre> I can clear the variable after use or set it = $null or I can entirely delete the variable. You can store any type of object in a variable, such as arrays, integers, and strings. But remember, in PowerShell, processes, services, etc are all also objects. <pre><code>$Rubbish = 1, 2, \"a\", \"\u00a3\u00a3\"\n$Rubbish.GetType()\n</code></pre> Usefully, we can cast a variable, so it has a fixed type. <pre><code>[int]$Rubbish = 1\n$Rubbish.GetType() \n</code></pre> If I pass a string to variable, it will automatically convert it. <pre><code>[int]$Rubbish = 1\n$Rubbish = \"123456789\"\n$Rubbish \n</code></pre> However, if it\u2019s a string of letters, PowerShell doesn\u2019t do miracles! <pre><code>[int]$Rubbish = 1\n$Rubbish = \"This will give you an error!\"\n$Rubbish \n</code></pre> You can translate a date into a datetime object, but the format of the input string is assumed to be US, mmddyyyy. <pre><code>[datetime]$OGGI = \"10/13/2025\"\n$OGGI \n</code></pre> Do some reading and see if you can figure out how to get PowerShell to expect the input string in ddmmyyyy format as we would use in Ireland. If you get it to work, include it in your scripts.</p> <p>For conversions of variable types, review here.</p> <p>A useful trick, I can store the output of a command for later use. <pre><code>$dir_listing = Get-ChildItem c:\\\n$dir_listing \n</code></pre> You can check if a variable exists using test-path variable:\\dir_listing When programmes get more complex, it can be tough keeping track of variables, I love this feature! <pre><code>New-Variable JORzVariable -value 3.142 -description \"PI with write-protection\" -option ReadOnly\nGet-Variable JORzVariable\n</code></pre> Notice that this was intended to be a constant, so I also write-protected it.</p>"},{"location":"3.%20Coding%20in%20Power%20Shell/3/#example","title":"Example","text":"<p>Below I do a simple tax calculation. <pre><code>$NET = 111\n$VAT = 0.23\n$VATAMOUNT = $amount * $VAT\n$GROSS = $NET + $VATAMOUNT\n$text = \"The total \u20ac$GROSS is the sum of the net value \u20ac$amount with the VAT amount \u20ac$VATAMOUNT at $VAT% VAT rate\"\n$text\n</code></pre></p>"},{"location":"3.%20Coding%20in%20Power%20Shell/4/","title":"Types","text":"<p>I have based these notes on this reference.  Characters and strings have the usual functions available, review the options at the reference provided. <pre><code>$StringValue = \"Yoo hoo!\"\n$StringValue.ToUpper()\n$StringValue.ToLower()\n</code></pre> You should be familiar with the concept of an array and iterating through it. When iterating, the first value is [0]. <pre><code>$MyArray = 1,2,3,4,5\n$MyArray[1]\n</code></pre> Rather than a single Integer type, we have int for 32-bit numbers and long for 64-bit numbers. These are signed, so an int can store +/- 2<sup>31</sup> values, the first bit denotes positive or negative. A long can store +/- 2<sup>63</sup> values. There is also a value for byte. <pre><code>$LittleNumber = 12345\n$LittleNumber.GetType()\n$BigNumber = 123456789123456789\n$BigNumber.GetType()\n</code></pre> In floating point, we have 32- and 64-bit options, single/float and double precision numbers. <pre><code>[float]$Floaty32 = 12.12\n$Floaty32.GetType()\n[double]$Floaty64 = 12345.1234\n$Floaty64.GetType()\n</code></pre> Interestingly, there is also a 128-bit decimal type.</p> <p>Review the reference provided, in particular the math types, although we do not need trigonometry in this module, we use it everywhere in science and engineering. The usual orders of precedence apply, but I use brackets to keep everything clear for myself.</p>"},{"location":"3.%20Coding%20in%20Power%20Shell/5/","title":"Conditional Branching","text":"<p>In informal terms, Conditional Branching occurs in a computer programme when based on a value, the programme jumps to a particular set of instructions. Its fundamental, you can find it in higher-level languages, but also down at the processor level in op-codes.</p> <p>Tests In most programming languages, we have the conditions, these are Equality Operators.</p> <ul> <li>gt greater than</li> <li>igt greater than, case-insensitive</li> <li>cgt greater than, case-sensitive</li> <li>ge greater than or equal</li> <li>ige greater than or equal, case-insensitive</li> <li>cge greater than or equal, case-sensitive</li> <li>lt less than</li> <li>ilt less than, case-insensitive</li> <li>clt less than, case-sensitive</li> <li>le less than or equal</li> <li>ile less than or equal, case-insensitive</li> <li>cle less than or equal, case-sensitive</li> </ul>"},{"location":"3.%20Coding%20in%20Power%20Shell/5/#if-and-elseif","title":"if and elseif","text":"<p>The first conditional statement we will consider is the if statement. This is also one of the oldest statements used in high level languages. Try this, vary one of the values. <pre><code>$Variable1 = 32\n$Variable2 = 32\nif ( $Variable1 -ne $Variable2  )\n{\n    Write-Output \"The condition was true\"\n}\n</code></pre> We can also use elseif. <pre><code>$day = 3\n\nif ( $day -eq 0 ) { $result = 'Sunday'        }\nelseif ( $day -eq 1 ) { $result = 'Monday'    }\nelseif ( $day -eq 2 ) { $result = 'Tuesday'   }\nelseif ( $day -eq 3 ) { $result = 'Wednesday' }\nelseif ( $day -eq 4 ) { $result = 'Thursday'  }\nelseif ( $day -eq 5 ) { $result = 'Friday'    }\nelseif ( $day -eq 6 ) { $result = 'Saturday'  }\n\n$result\n</code></pre> Read this reference. Create some examples using -like. My example finds a depth sounder in a standard NMEA0183 serial stream. <pre><code>$FINDVALUE = '$SDDPT,2.98,,*66'\nif ( $FINDVALUE -like '$SD*')\n{\n    Write-Output \"Found a depth sounder\"\n}\n</code></pre></p>"},{"location":"3.%20Coding%20in%20Power%20Shell/5/#switch","title":"Switch","text":"<p>I have based these notes on this reference.  Any C programmers will start being at home now! In the previous session we used if and elseif to select a day, here I use switch. <pre><code>$day = 4\n\nswitch ( $day )\n{\n    0 { $result = 'Sunday'    }\n    1 { $result = 'Monday'    }\n    2 { $result = 'Tuesday'   }\n    3 { $result = 'Wednesday' }\n    4 { $result = 'Thursday'  }\n    5 { $result = 'Friday'    }\n    6 { $result = 'Saturday'  }\n}\n\n$result\n</code></pre></p>"},{"location":"3.%20Coding%20in%20Power%20Shell/6/","title":"Loops","text":"<p>Whenever code needs to be executed many times, we use loops. Almost any code I write to provide a service will run in an endless loop until I hit [ctrl][c]. I presume you understand break (which exits the loop) and continue (which goes to the next cycle of the loop) and I will not explain them here.</p>"},{"location":"3.%20Coding%20in%20Power%20Shell/6/#for-loop","title":"For loop","text":"<p>The for loop has the syntax:  <pre><code>for (&lt;Init&gt;; &lt;Condition&gt;; &lt;Repeat&gt;)\n{\n    &lt;Statement list&gt;\n}\n</code></pre> Init is a command before the loop begins, for example  <pre><code>$counter=0 A \n</code></pre> A Condition resolves to true or false and determines whether the loop runs. </p> <p>Repeat executes every time the loop runs.</p> <p>As a simple example... <pre><code>for ($counter = 0; $counter -lt 10; $counter++)\n{\n    $counter\n}\n</code></pre></p>"},{"location":"3.%20Coding%20in%20Power%20Shell/6/#foreach","title":"ForEach","text":"<p>We can iterate through an array using foreach. <pre><code>$MyArray = \"J\", \"o\", \"h\", \"n\"\nforeach ($Letter in $MyArray)\n{\n    $Letter\n}\n</code></pre></p>"},{"location":"3.%20Coding%20in%20Power%20Shell/6/#while","title":"While","text":"<p>While loops can have a simple format. <pre><code>while($val -ne 3)\n{\n    $val++\n    Write-Host $val\n}\n</code></pre> Some while loops are a little more complicated. This is a simple menu example from 4sysops.com. It takes user input and carries out actions depending on the user input. <pre><code>while(($inp = Read-Host -Prompt \"Select a command\") -ne \"Q\"){\n    switch($inp){\n       L {\"File will be deleted\"}\n       A {\"File will be displayed\"}\n       R {\"File will be write protected\"}\n       Q {\"End\"}\n       default {\"Invalid entry\"}\n       }\n    }\n</code></pre></p>"},{"location":"3.%20Coding%20in%20Power%20Shell/6/#do-until","title":"Do Until","text":"<p>A do until loop is very similar to while. <pre><code>$a = 0 \ndo\n{\n    \u201cStarting Loop $a\u201d\n    $a\n    $a++\n    \u201cNow `$a is $a\u201d\n} until ($a -ge 5)\n</code></pre></p>"},{"location":"3.%20Coding%20in%20Power%20Shell/7/","title":"Piping Commands","text":"<p>In Linux and in PowerShell, one of the most powerful things we can do is to pipe the output of one command to be the input of another. The pipe symbol is |</p> <p>Try the example: <pre><code>Dir | Format-Table | Out-Host\n</code></pre></p>"},{"location":"4.%20Server%20Configuration/1/","title":"Background","text":"<p>To do these exercises, you will need access to some Windows VMs.  If you are completing this on Azure Labs, you need a VM with Hyper-V. If you are working on campus, or using a home machine with VMWare Workstation, you should be able to complete these exercises. On a real project, I will install remote tools of some kind on my jump server or a dedicated management VM.</p>"},{"location":"4.%20Server%20Configuration/1/#remoting","title":"Remoting","text":"<p>To connect to another computer using PowerShell, I use the following. <pre><code>$REMOTE_SERVER = 'server-1'\n\n# Connect to server-1\nEnter-PSSession $REMOTE_SERVER\n# Do stuff on the remote server\nExit-PSSession\n</code></pre> This may be a bit more complex!  There may be firewall, policy issues and permissions you need to sort on  a per case basis.</p>"},{"location":"4.%20Server%20Configuration/1/#dc-build","title":"DC Build","text":"<p>The fist thing I do when creating a new environment is to create the domain controllers. I spin up a Windows Server with a GUI as DC1 and run the following script to install the correct software. <pre><code>Install-WindowsFeature -name AD-Domain-Services \u2013IncludeManagementTools\n\nImport-Module ADDSDeployment\nInstall-ADDSForest `\n-CreateDnsDelegation:$false `\n-DatabasePath \"C:\\Windows\\NTDS\" `\n-DomainMode \"WinThreshold\" `\n-DomainName \"ads.kmn.ie\" `\n-DomainNetbiosName \"ads\" `\n-ForestMode \"WinThreshold\" `\n-InstallDns:$true `\n-LogPath \"C:\\Windows\\NTDS\" `\n-NoRebootOnCompletion:$false `\n-SysvolPath \"C:\\Windows\\SYSVOL\" `\n-Force:$true\n\nShutdown /r /t 0\n</code></pre> Next I need to configure the domain controller. Note I use variables where possible, it reduce the risk of human error. <pre><code>$SERVERNAME = \"dc1\"\n$FOREST = \"ads.kmn.ie\"\n$DNSNAME = $SERVERNAME + \".\" + $FOREST\n\n# Set the IP address for the DC\nRename-Computer -NewName $SERVERNAME\nGet-NetIPAddress\nNew-NetIPAddress -InterfaceIndex 16 -IPAddress 172.27.6.11 -PrefixLength 24 -DefaultGateway 172.27.6.20\nRestart-Computer\n\n# Configure AD, DNS\nInstall-ADDSForest -DomainName $FOREST\nInstall-WindowsFeature DHCP -IncludeManagementTools\n\n# Configure DHCP, add a single scope\nAdd-DhcpServerInDC -DnsName $DNSNAME -IPAddress 172.27.6.11\nAdd-DhcpServerv4Scope -Name InfraServers -StartRange 172.27.6.150 -EndRange 172.27.6.199 -SubnetMask 255.255.255.0\n\n# Set time to sync'h with a local NTP server.\nw32tm /config /manualpeerlist:172.27.15.254 /syncfromflags:manual /update\n</code></pre> We always have a second DC, in this case I use Windows Core and the following script. <pre><code>$SERVERNAME = \"dc2\"\n$FOREST = \"ads.kmn.ie\"\n$DNSNAME = $SERVERNAME + \".\" + $FOREST\n\n# Set the IP address for the DC\nRename-Computer -NewName $SERVERNAME\nGet-NetIPAddress\nNew-NetIPAddress -InterfaceIndex 9 -IPAddress 172.27.6.12 -PrefixLength 24 -DefaultGateway 172.27.6.20\nSet-DnsClientServerAddress -InterfaceIndex 9 -ServerAddresses 172.27.6.11\nRestart-Computer\n\n# Join the existing Domain\nAdd-Computer -DomainName $FOREST -Restart\n\n# Install software\nInstall-WindowsFeature -Name AD-Domain-Services -IncludeManagementTools\n\n# Add this as a second DC\nInstall-ADDSDomainController -DomainName $FOREST -InstallDns:$true -Credential (Get-Credential \"janus\\administrator\")\n\n# Configure DHCP\nInstall-WindowsFeature DHCP -IncludeManagementTools\nAdd-DhcpServerInDC -DnsName $DNSNAME -IPAddress 172.27.6.12\n</code></pre> I verify each DNS using Resolve-Dnsname Fig 16 is for a different system from that configured above.</p> Fig 16. Typical output."},{"location":"4.%20Server%20Configuration/1/#dhcp","title":"DHCP","text":"<p>Sometimes I will create and configure DHCP scopes using automation. <pre><code>Add-DhcpServerv4Scope -name \"ISP\" -StartRange 10.1.1.100 -EndRange 10.1.1.254 -SubnetMask 255.255.255.0 -State Active\nAdd-DhcpServerv4ExclusionRange -ScopeID 10.1.1.0 -StartRange 10.1.1.200 -EndRange 10.1.1.254\nSet-DhcpServerv4OptionValue -OptionID 3 -Value 10.1.1.1 -ScopeID 10.1.1.0 -ComputerName dc1.ads.electric-petrol.ie\n</code></pre></p>"},{"location":"4.%20Server%20Configuration/1/#demote-a-dc","title":"Demote a DC","text":"<p>If I'm deprecating a DC, I need to do so cleanly. Its really messy to remove a DC from the directory if it is no longer bootable. <pre><code>&lt;#\nRemote server setup script.\nDemotes a DC\nRun one line at a time, under supervision!\n#&gt;\n$REMOTE_SERVER = 'server-1'\n\n# Connect to server-1\nEnter-PSSession $REMOTE_SERVER\n\nImport-Module ADDSDeployment\nUninstall-ADDSDomainController -DemoteOperationMasterRole:$true -ForceRemoval:$true -Force:$true\n\nExit-PSSession\n</code></pre> I may then get the computer to leave the domain. <pre><code>Remove-Computer -UnjoinDomaincredential ads\\Administrator -PassThru -Verbose -Force\n</code></pre></p>"},{"location":"4.%20Server%20Configuration/2/","title":"Creating Users","text":"<p>Adding users in bulk is one of those big jobs that is easy to mangle. c. 2002 I did a study where I provided a printout to help desk staff to figure out how effectively we could create users manually. The error rate was staggering! These are tasks we should always automate from an authoritative source. </p> <p>By now you are used to reading my scripts, work through this one and see if it makes sense.</p> <p><pre><code>#Enter a path to your import CSV file\n$ADUsers = Import-csv C:\\Powershell\\WT3\\CLOD2023.csv\n\n# Typo in the domain name!!!!\n$Organisation = \"DC=ads,DC=solarsubmaines,DC=com\"\n$Classgroup = \"PGDipCLOD2022\"\n\n# Add OUs for User and for this specific group\nNew-ADOrganizationalUnit -Name $Classgroup -Path $Organisation -ProtectedFromAccidentalDeletion $false\nNew-ADOrganizationalUnit -Name \"Users\" -Path \"OU=$Classgroup,$Organisation\" -ProtectedFromAccidentalDeletion $false\nNew-ADOrganizationalUnit -Name \"Groups\" -Path \"OU=$Classgroup,$Organisation\" -ProtectedFromAccidentalDeletion $false\n\n# Add an OU for domain servers\nNew-ADOrganizationalUnit -Name \"Servers\" -Path \"OU=$Classgroup,$Organisation\" -ProtectedFromAccidentalDeletion $false\n\n# Create a group for these users\nNew-ADGroup -Name $Classgroup -Description \"PGDip Cloud 2022\" -GroupCategory Security -GroupScope DomainLocal -Path \"OU=Groups, OU=$Classgroup,$Organisation\"\n\nforeach ($User in $ADUsers)\n{\n\n       $Username    = $User.username\n       $Password    = $User.password\n       $Firstname   = $User.firstname\n       $Lastname    = $User.lastname\n       $Department  = $User.department\n       $OU          = $User.ou\n\n       #Check if the user account already exists in AD\n       if (Get-ADUser -F {SamAccountName -eq $Username})\n       {\n               #If user does exist, output a warning message\n               Write-Warning \"A user account $Username has already exist in Active Directory.\"\n       }\n       else\n       {\n            #If a user does not exist then create a new user account\n            #Account will be created in the OU listed in the $OU variable in the CSV file     \n            New-ADUser `\n            -SamAccountName $Username `\n            -UserPrincipalName \"$Username@ads.solarsubmaines.com\" `\n            -Name \"$Firstname $Lastname\" `\n            -GivenName $Firstname `\n            -Surname $Lastname `\n            -Enabled $True `\n            -ChangePasswordAtLogon $True `\n            -DisplayName \"$Lastname, $Firstname\" `\n            -Department $Department `\n            -Path $OU `\n            -AccountPassword (convertto-securestring $Password -AsPlainText -Force)\n\n            # Add or change any other parameters\n            Set-ADUser -Identity $Username -Description \"PGDip Student\" -Organization \"ATU\"\n\n            # Add the user to a primary group\n            Add-ADGroupMember -Identity $Classgroup -Members $Username\n\n       }\n}\n</code></pre> I need to create a list of users. I show my list in Excel, which I save as a CSV file. Student names are obfuscated.</p> Fig 17. Users CSV file."},{"location":"5.%20Configuration%20at%20Scale/1/","title":"Background","text":"<p>We can install features very easily in Windows Server by using Power Shell. The command  <pre><code>Get-WindowsFeature\n</code></pre> returns a list of available roles and features. </p> <p>The command <pre><code>Install-WindowsFeature\n</code></pre> installs the required role or feature and  <pre><code>Uninstall-WindowsFeature \n</code></pre> removes a feature.</p> <p>However, maintaining a server can be more of a challenge, ensuring it is always in the correct state. Doing so for a fleet of servers is another problem again! </p> <p>These notes are provided to introduce you to Desired State Configuration (DSC) in Windows Server. Managed Object Format (MOF) is the language used to describe Common Information Model (CIM) classes; we need to compile MOF files for using with DSC.</p> <p>To do these exercises, you will need access to some Windows VMs.  If you are completing this on Azure Labs, you need a VM with Hyper-V.</p> <p>If you are working on campus, or using a home machine with VMWare Workstation, you should be able to complete these exercises.</p>"},{"location":"5.%20Configuration%20at%20Scale/1/#desired-state-configuration","title":"Desired State Configuration","text":"<p>Setting up a server is one thing, keeping it with that configuration is another. Desired State Configuration (DSC) is a set of Power Shell features that allows us to configure and maintain a configuration of Windows Server 2019, to make sure every server is in the desired state. We could do this with scripts on a timed job, but this is a good way to automate this process as well.  Using DSC, we can - Install and remove server roles and features - Create registry settings - Create files and folders and manage directories - Start and stop processes - Manage groups and users - Run other PowerShell scripts </p> <p>Most importantly, we can examine a server to see if it is in its desired state and if not, fix it! There are a range of built-in providers in DSC that enable this functionality.</p> Fig 18. DSC Providers. <p>Note that one of the providers is called File, I can use this to automatically copy an important file to any server.  Also notice the provider WindowsFeature. To see which features I can add, I can use the command  </p> <p><pre><code>Get-WindowsFeature\n</code></pre> I am not going to show the output, it scrolls off the page!\u2003</p>"},{"location":"5.%20Configuration%20at%20Scale/2/","title":"DSC Example","text":"<p>I create dsc1.ps1 on my domain controller, dc-1. <pre><code>Configuration DscConfiguration\n{\n    param\n    (\n        [string[]]$ComputerName='localhost'\n    )\n\n    Import-DscResource -ModuleName PsDesiredStateConfiguration\n\n    Node $ComputerName\n    {\n        WindowsFeature MyFeatureInstance\n        {\n            Ensure = 'Present'\n            Name = 'RSAT'\n        }\n\n        WindowsFeature My2ndFeatureInstance\n        {\n            Ensure = 'Present'\n            Name = 'DNS'\n        }\n        File HelloWorld {\n            SourcePath = \"C:\\Users\\Administrator\\Documents\\jor.txt\"\n            DestinationPath = \"C:\\Temp\\HelloWorld.txt\"\n            Ensure = \"Present\"\n            Contents   = \"Hello World from DSC!\"\n        }\n    }\n}\nDscConfiguration\n</code></pre></p>"},{"location":"5.%20Configuration%20at%20Scale/2/#anatomy","title":"Anatomy","text":"<p>The outer block is the configuration block, with the name DscConfiguration. We could add the node to run this against using <pre><code>Node @('localhost', 'server-1')\n</code></pre> In my script, I added a parameter so that the computers this will act against can be entered at the command line. Below I just use the ComputerName parameter \u201clocalhost\u201d.</p> Fig 19. Output of script."},{"location":"5.%20Configuration%20at%20Scale/2/#mof-file","title":"MOF File","text":"<p>When I ran this, it resolved all variables and compiled a human readable MOF file. A folder gets created called whatever the script name is (DscConfiguration). A MOF file gets created for each node and is saved in the script name directory. This is for the MOF files and any other supporting files which are created. I only have a single example for localhost. <pre><code>/*\n@TargetNode='localhost'\n@GeneratedBy=administrator\n@GenerationDate=12/01/2022 16:16:45\n@GenerationHost=DC-1\n*/\n\ninstance of MSFT_RoleResource as $MSFT_RoleResource1ref\n{\nResourceID = \"[WindowsFeature]MyFeatureInstance\";\n Ensure = \"Present\";\n SourceInfo = \"C:\\\\PowerShell\\\\wt4\\\\dsc1.ps1::10::9::WindowsFeature\";\n Name = \"RSAT\";\n ModuleName = \"PsDesiredStateConfiguration\";\n\nModuleVersion = \"1.0\";\n\n ConfigurationName = \"DscConfiguration\";\n\n};\ninstance of MSFT_RoleResource as $MSFT_RoleResource2ref\n{\nResourceID = \"[WindowsFeature]My2ndFeatureInstance\";\n Ensure = \"Present\";\n SourceInfo = \"C:\\\\PowerShell\\\\wt4\\\\dsc1.ps1::16::9::WindowsFeature\";\n Name = \"DNS\";\n ModuleName = \"PsDesiredStateConfiguration\";\n\nModuleVersion = \"1.0\";\n\n ConfigurationName = \"DscConfiguration\";\n\n};\ninstance of OMI_ConfigurationDocument\n\n                    {\n Version=\"2.0.0\";\n\n\n                        MinimumCompatibleVersion = \"1.0.0\";\n                        CompatibleVersionAdditionalProperties= {\"Omi_BaseResource:ConfigurationName\"};\n                        Author=\"administrator\";\n                        GenerationDate=\"12/01/2022 16:16:45\";\n                        GenerationHost=\"DC-1\";\n                        Name=\"DscConfiguration\";\n                    };\n</code></pre></p>"},{"location":"5.%20Configuration%20at%20Scale/3/","title":"Apply the Configuration","text":"<p>To apply the configuration, I run the command  <pre><code>Start-DscConfiguration -Path C:\\PowerShell\\WT4\\DscConfiguration -Verbose -Wait -Force\n</code></pre></p> Fig 20. Output of script."},{"location":"5.%20Configuration%20at%20Scale/3/#testing","title":"Testing","text":"<p>Despite the warning, PowerShell created the folder C:\\Temp and the file HelloWorld.txt To verify, run the command  <pre><code>Get-Content C:\\Temp\\HelloWorld.txt\n</code></pre> To check the DSC Configuration Store, run the command  <pre><code>Get-DscConfiguration\n</code></pre></p>"},{"location":"5.%20Configuration%20at%20Scale/3/#remove-the-configuration","title":"Remove the Configuration","text":"<p>To delete the configuration and stop using it, use the commands as shown below. <pre><code>$Session = New-CimSession -ComputerName \"localhost\"\nRemove-DscConfigurationDocument -Stage Current -CimSession $Session\n</code></pre> After running this successfully, check the DSC Configuration Store again, it should be clear.</p>"},{"location":"5.%20Configuration%20at%20Scale/3/#finally","title":"Finally","text":"<p>We could use a timer to push this configuration or we could have a repository of MOF files on a file server and we could get the servers to pull configurations. We can use an SMB share or web services; web ports tend to be more flexible in a large environment. We really need a certificate authority (CA) set up or we need a self-signed certificate to use this over the web.</p>"}]}